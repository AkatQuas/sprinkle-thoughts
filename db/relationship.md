> 摘抄自《计算机科学基础》，对数据库的描述并不详尽，比如SQL语句就没有介绍，因此更多内容可参见《数据库系统基础教程》Jeffrey D. Ullman, Jennifer Widom的版本。

# 关系

“关系”的概念与关系的集合论定义是紧密相关的。

关系也是元组的集合，表中各行（也称*元组*）排列的次序不重要。

每一行的各个组分（也称*属性*）的次序是关键的。

一张关系表包含两个方面：
1. 列名的集合（属性集合）
1. 包含信息的行（信息元组）

第1项，属性的集合也被称为关系的模式（scheme）。

# 数据库

关系的集合称为数据库。

数据库中各关系的模式组成的集合就是数据库的模式。要注意数据库模式(它告诉我们与数据库中信息组织方式有关的信息)与各关系中元组的集合(数据库中存储的实际信息)之间的区别。

## 查询基本操作

1. `insert(t,R)`。如果元组t尚未出现在关系R中，就将它添加到R中。该操作与词典或二元关系的*插入*操作有着相同的精神。
2. `delete(X,R)`。在这里，X是某些元组的规范。它是由对应R各属性的组分组成的，每个组分都会是下面两者之一。
    - 一个值。
    - 符号*，表示可以接受任意值。该操作的效果是删除满足规范X的所有元组。
3. `lookup(X,R)`。该操作的结果是得到R中匹配规范X的元组形成的集合，X是个象征性的元组，就跟第(2)项中描述的一样。

## 表示关系的数据结构的设计

> 在使用关系数据模型时，如何选择合适的数据库模式很重要
> 1. 如果将两个独立类型的信息结合成一个关系模式，就可能被迫多次重复同样的数据事实。
> 2. 在属性表示相互联系的信息时，不要把它们分开。 

## 键

很多数据库关系可被视作从某些属性的集合到其余属性的函数。因为函数的数据结构比一般关系的数据结构要简单一些，所以如果知道可以作为函数定义域的属性集合是比较好的。这样的属性集合被称作*键*。

关系的*键*是一项或多项属性的集合，满足”在任何情况下，以键属性为标题的列中不会出现相同的值“。

> 选择合适的键
> 1. 不能只靠观察关系的几个示例就确定键。
> 2. 不存在所谓的“正确的键”的选择，选择什么属性作为键，取决于对关系所含数据的类型作出的假设。

# 关系的主要存储结构

这里有一些可用于表示关系的结构。

1. 二叉查找树，在定义域值上有“小于”关系以安排元组的位置，可以用来促进指定了定义域值的操作。
2. 以定义域值作为数组索引，用特征向量的数组。
3. 散列定义域值以找到散列表元的散列表。
4. 原则上看，元组组成的链表是一种候选结构，但是它对任何类型的操作都没有促进作用。

当关系不是二元关系时，同样的结构也是可以使用的。定义域不再只有单个属性，而是可能结合k个属性，称为*定义域属性*，或在明确所指的属性集合时，直接称为*定义域*。此时，定义域的值就是k元组，各组分对应定义域的各属性。而*值域属性*是指哪些定义域属性以外的属性，可以有多个组分。

一般而言，必须选出想要作为定义域的那些属性。简单情形，对于具有一个或少量属性作为关系的键的情况，直接拿键属性作为定义域即可，其余属性作为值域。没有键时，可以选择任意属性集合作为定义域。

一旦选择了定义域，就可以从上述提到的4种数据结构中任选其一表示该关系，或者其实也可以选择另一种结构。不过，通常会选择以定义域值作为索引的散列表，而且一般都会这么做。

所选的结构就称为该关系的*主索引结构*。形容词“主”表示元组的位置是由该结构确定的。*索引*是在给定所需要的 组的一个或多个组分的情况下协助找到元组的数据结构。

> 主索引的选择
> 1. 将关系模式的键作为函数的定义域，将其余属性作为值域通常是很实用的。
> 2. 如果最常见的查询所指定的是不构成键的属性的值，就可能要选用该属性集合作为定义域，将其余属性作为值域。
> 3. 主索引结构定义域的选择可能对执行“常规”查询速度有着最大的影响。

## 主索引为散列表的插入、删除、查找

把注意力放在作为主索引结构的散列表上。如果操作指定了定义域的值，那么就要散列该值以找到散列表元。

1. 插入元组t，就要检查相应的散列表元，看看t是否已经位列其中，如果没有就在该散列表元对应的链表中新建新单元来容纳t。
2. 要删除匹配规范X的元组，就要根据据X找出定义域值，进行散列以得出相应的散列表元，然后沿着该散列表元对应的链表向下查找，将匹配规范X的各元组都删除。
3. 要根据规范X查找元组，还是要从X找到定义域值，进行散列以得出相应的散列表元。沿着对应该散列表元的链表向下查找，将链表中匹配规范X的各元组分别作为回应生成。

如果操作没有指定定义域值，就不会这么走运了。插入操作就总是要完整地指定被插入的元组，而删除或查找操作可能不能这样。在那样的情况下，必须对所有的散列表元列表进行查找，找到匹配的元组，并分别删除或列出它们。

## 辅助索引

可以在给定某一属性或某些属性的值的情况下找到元组，但不能用来在整个结构中放置元组的数据结构，就是*辅助索引*。

一般而言，关系R属性A上的*辅助索引*是满足以下条件的有序对(v, p)的集合。
1. v是属性A的值。
2. p是指向关系R主索引结构中某个元组的指针，该元组的“A”组分的值为v。

对属性A的值为v的各元组来说，辅助索引都有对应的有序对。

可以使用表示二元关系的任意数据结构来存储辅助索引。通常会期望使用基于属性A的值的散列表。只要散列表元的数量不大于属性A不同值的数量，在给定所需的v值的情况下，在散列表中查找有序对(v, p)通常都可以预期不错的性能，也就是平均O(n/B)的时间。这里的n是有序对的数量，而B是散列表元的数量。

> 创建辅助索引
> 如果元组的一个或多个组分的值已经给定，辅助索引的存在通常会让查找元组的工作变得更加容易。补过还要考虑：
> 1. 所创建的每个辅助索引都会让我们在关系中插入或删除信息时花费额外的时间。
>       - 插入。如果要插入一个新元组，其对应属性A的组分的值为v，就必须创建有序对(v,p)，其中p是指向主结构中新记录的指针。然后，再把有序对(v,p)插入到辅助索引中。
>      - 删除。要删除对应A的组分的值为v的元组时，首先一定要记得已经删除了指向该元组的指针，比方说是p。然后，要深入辅助索引结构，并检查所有第一个组分为v的有序对，直到从其中找出第二个组分为p的有序对为止。然后将该有序对从辅助索引结构中删除。
> 2. 只为那些可能需要查找数据的属性构建辅助索引。

# 关系间的导航

关系的导航就是从一个关系跳转到另一个关系的操作。

索引的建立不仅仅在使得在本关系中的查询操作变得简单，也使得导航的操作变得简单。

# 关系代数

## 操作数

在关系代数中，所有的操作数都是关系，可以时常量，也可以是未知量。每个操作数都有特定的模式（即关系中的列命名的属性的集合）。

## 集合运算符

3种常见的集合运算：并、交、差。
使用这些运算符的操作数的模式一定要相同，这样结果的模式自然是这两个参数的模式。

## 选择运算符

从关系中提取某些条件的元组，可以使用*选择*运算符，记作 σ<sub>C</sub>(R)，C是条件，R是关系操作数。

选择运算的结果是模式与R的模式相同的关系。把在将条件C中的属性A替换为元组t对应列A的组分时使得条件C为真的每个元组t都放入该关系中。

## 投影运算符

选择运算符会生成某关系删除若干行之后的副本，为了得到关系删除若干列（属性）的副本，可以使用*投影*运算符，记作π<sub>B<sub>1</sub>,...B<sub>n</sub></sub>(R)，表示关系R在属性B<sub>1</sub>,...B<sub>n</sub>上的投影。

取R中的元组t，提取其属性B<sub>1</sub>,...B<sub>n</sub>中的组分，可能存在多个元组得到相同的投影，此时，只会有一个副本会进入到中π<sub>B<sub>1</sub>,...B<sub>n</sub></sub>(R)。

## 关系的联接

用来表示两个关系被关联起来，从而可以从一个关系向另一个关系导航的概念。假设有两个关系R和S，其属性集合（模式，scheme）分别是{A<sub>1</sub>,...A<sub>m</sub>}，{B<sub>1</sub>,...B<sub>n</sub>}。要从两个集合中各选出一些属性，而把这些属性成为以R和S为参数的*联接*运算的参数。

就要从R中取出各元组r，从S中取出各元组s加以比较。如果其中的属性满足联接运算的条件，那么r和s就形成了一个元组（要剔除相同的组分）。如果属性名相同，但是属性意义不相同，需要重命名其中某个属性。

# 关系代数运算的实现

介绍一些常见而又相对简单的关系代数运算的实现策略。

## 交、并、差

可以先排序，后合并，再进行并、交、差的运算。

如果参加运算的两个关系R与S各含n个元组，就要花O(nlogn)的时间为其排序并用O(n)的时间合并，总共需要的时间为O(nlogn)。

还有别的方式。

1. 首先不去考虑为同时出现在R和S中的元组消除重复副本的事情，重复的元组可能性比较小而且也许重复不是个问题。或者在后续的阶段中消除重复会更加方便。

1. 使用索引。例如R具有属性A上的索引，而该属性时S的键。那么要取二者的并集R ∪ S，可以首先从S的元组开始，并依次检查R的每个元组t。会在组分A中找到t的值，并使用该索引查找S中A组分的值相同的元组。如果S中的这一元组与t相同，就不要再将t第二次放入该并集中，相反的，如果S中不存在键的值与t中组分A相同的元组，或者键值相同但是元组不相同，则就要将t放入并集中。

## 投影运算的实现

原则上讲，在执行投影运算时，只能检验完每个元组，并略去那些与未出现在投影列表中的属性对应的组分。索引是一点忙都帮不上的。此外，在计算了各元组的投影后，可能发现会留下很多重复的元组。于是必须要消除重复！消除重复有两种：

- 将结果关系进行排序，次序上与前一个元组相同的元组都要被删除
- 用集合（比如散列表）去存储结果关系，这样就可以避免插入重复元组。

如果关系R中有n个元组，那么要消除重复前为关系S排序所需的时间为O(nlogn)。使用散列表则整个投影运算平均要花O(n)的时间，散列略优于排序。

## 选择运算的实现

当关系R没有使用索引时，则必须要检查R中所有元组，才能得到结果关系S。

当R中使用了索引，则可以利用索引来直接找到满足条件C的元组，会节省很多时间。

当条件中同时使用了索引和非索引，可以先利用执行索引条件，得到初筛，然后对初筛进行遍历，以得到满足剩余条件的元组。

## 联接的实现

假设想要对模式为{A,B}的关系R和模式为{B,C}的关系S进行自然联接，并假设该联接时两个关系的B属性之间存在相等关系的自然联接。

直观而又缓慢的方式就是暴力地分别遍历两个关系，称作*嵌套循环联接*，寻找其中B属性相同的元组。

一种高效的联接方式是使用索引。假设S有属性B上的索引，则可以先遍历R的各元组，并在S的索引中查找匹配的元组。进一步的，S和R在属性B上都有索引，则可以任选其一来用。

如果两者在属性B上不存在索引，利用*排序联接*还是能比*嵌套循环联接*做的更好。先将R和S的元组合并在一起，重新组合时，B祖坟成为所有元组的第一个组分，并加上额外的组分来区分合并后的元组时来自于R还是S。合并完成后根据B组分进行排序，再沿着排序表向下遍历，寻找具有相同B组分的来自R和S的组分进行联接，生成联接后关系中元组所花时间时与生成元组数成比例的。

# 关系的代数法则

对表达式进行等价变形，可以优化表达式，即优化查询过程。

因为一般而言当运算应用到较小的关系上时所花的时间较少，所以尽可能早地应用选择运算是极为有利的。从代数的角度来看，如果想早点应用选择运算，可以使用代数法则让选择运算符沿着表达式树向下传递，进行下压操作。

至于涉及投影操作，投影不能像选择操作一样可以被压倒并、差、交之下，投影只能压到并集之下。

> 摘抄自《计算机科学基础》，对数据库的描述并不详尽，比如SQL语句就没有介绍，因此更多内容可参见《数据库系统基础教程》Jeffrey D. Ullman, Jennifer Widom的版本。